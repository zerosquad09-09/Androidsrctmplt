// Gradle build config for Godot Engine's Android port.

plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

apply from: 'config.gradle'

// -------------------------------------------------------------------
// Repositories
// -------------------------------------------------------------------
allprojects {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
        maven { url "https://plugins.gradle.org/m2/" }
        maven { url "https://s01.oss.sonatype.org/content/repositories/snapshots/" }

        // Godot user plugins custom Maven repos
        String[] mavenRepos = getGodotPluginsMavenRepos()
        if (mavenRepos != null && mavenRepos.size() > 0) {
            for (String repoUrl : mavenRepos) {
                maven { url repoUrl }
            }
        }
    }
}

// -------------------------------------------------------------------
// Configurations
// -------------------------------------------------------------------
configurations {
    devImplementation {}
    monoImplementation {}
}

// -------------------------------------------------------------------
// Dependencies
// -------------------------------------------------------------------
dependencies {
    // Ads / mediation SDKs
    implementation "com.google.ads.mediation:adcolony:4.8.0.2"
    implementation "com.google.ads.mediation:facebook:6.14.0.0"
    implementation "com.google.ads.mediation:vungle:6.12.1.1"
    implementation "com.google.android.gms:play-services-ads:23.3.0"

    // AndroidX
    implementation "androidx.fragment:fragment:$versions.fragmentVersion"
    implementation "androidx.core:core-splashscreen:$versions.splashscreenVersion"

    // Godot Engine lib (choose: project or prebuilt AAR)
    if (rootProject.findProject(":lib")) {
        implementation project(":lib")
    } else if (rootProject.findProject(":godot:lib")) {
        implementation project(":godot:lib")
    } else {
        debugImplementation   fileTree(dir: 'libs/debug', include: ['**/*.jar', '*.aar'])
        devImplementation     fileTree(dir: 'libs/dev',   include: ['**/*.jar', '*.aar'])
        releaseImplementation fileTree(dir: 'libs/release', include: ['**/*.jar', '*.aar'])
    }

    // Godot user plugins (remote deps)
    String[] remoteDeps = getGodotPluginsRemoteBinaries()
    if (remoteDeps != null && remoteDeps.size() > 0) {
        for (String dep : remoteDeps) implementation dep
    }

    // Godot user plugins (local deps)
    String[] pluginsBinaries = getGodotPluginsLocalBinaries()
    if (pluginsBinaries != null && pluginsBinaries.size() > 0) {
        implementation files(pluginsBinaries)
    }

    // Auto-pickup addons (res://addons)
    String addonsDirectory = getAddonsDirectory()
    if (addonsDirectory != null && !addonsDirectory.isBlank()) {
        implementation fileTree(dir: "$addonsDirectory", include: ['*.jar', '*.aar'])
    }

    // .NET support
    String jar = '../../../../modules/mono/thirdparty/libSystem.Security.Cryptography.Native.Android.jar'
    if (file(jar).exists()) {
        monoImplementation files(jar)
    }
}

// -------------------------------------------------------------------
// Android Config
// -------------------------------------------------------------------
android {
    namespace 'com.godot.game'

    compileSdkVersion versions.compileSdk
    buildToolsVersion versions.buildTools
    ndkVersion versions.ndkVersion

    defaultConfig {
        applicationId getExportPackageName()
        versionCode getExportVersionCode()
        versionName getExportVersionName()
        minSdkVersion getExportMinSdkVersion()
        targetSdkVersion getExportTargetSdkVersion()

        ndk {
            // FIX for Gradle 8.2.1: expand into multiple calls
            getExportEnabledABIs().each { abi ->
                abiFilters abi
            }
        }

        manifestPlaceholders = [
            godotEditorVersion   : getGodotEditorVersion(),
            godotRenderingMethod : getGodotRenderingMethod()
        ]

        missingDimensionStrategy 'products', 'template'

        aaptOptions {
            // Allow Godot hidden files
            ignoreAssetsPattern "!.svn:!.git:!.gitignore:!.ds_store:!*.scc:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"
        }
    }

    compileOptions {
        sourceCompatibility versions.javaVersion
        targetCompatibility versions.javaVersion
    }

    kotlinOptions {
        jvmTarget = versions.javaVersion
    }

    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/NOTICE'

        if (shouldNotStrip()) {
            doNotStrip '**/*.so'
        }

        jniLibs {
            useLegacyPackaging shouldUseLegacyPackaging()
        }

        // Ensure Godotâ€™s libc++_shared.so wins over deps
        pickFirst 'lib/x86/libc++_shared.so'
        pickFirst 'lib/x86_64/libc++_shared.so'
        pickFirst 'lib/armeabi-v7a/libc++_shared.so'
        pickFirst 'lib/arm64-v8a/libc++_shared.so'
    }

    signingConfigs {
        debug {
            if (hasCustomDebugKeystore()) {
                storeFile file(getDebugKeystoreFile())
                storePassword getDebugKeystorePassword()
                keyAlias getDebugKeyAlias()
                keyPassword getDebugKeystorePassword()
            }
        }
        release {
            File keystoreFile = file(getReleaseKeystoreFile())
            if (keystoreFile.isFile()) {
                storeFile keystoreFile
                storePassword getReleaseKeystorePassword()
                keyAlias getReleaseKeyAlias()
                keyPassword getReleaseKeystorePassword()
            }
        }
    }

    buildTypes {
        debug {
            zipAlignEnabled shouldZipAlign()
            signingConfig shouldSign() ? signingConfigs.debug : null
        }
        dev {
            initWith debug
            zipAlignEnabled shouldZipAlign()
            signingConfig shouldSign() ? signingConfigs.debug : null
        }
        release {
            zipAlignEnabled shouldZipAlign()
            signingConfig shouldSign() ? signingConfigs.release : null
        }
    }

    flavorDimensions 'edition'
    productFlavors {
        standard {}
        mono {}
    }

    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            res.srcDirs = ['res']
            aidl.srcDirs = ['aidl']
            assets.srcDirs = ['assets']
        }
        debug.jniLibs.srcDirs   = ['libs/debug', 'libs/debug/vulkan_validation_layers']
        dev.jniLibs.srcDirs     = ['libs/dev']
        release.jniLibs.srcDirs = ['libs/release']
    }

    applicationVariants.all { variant ->
        variant.outputs.all { output ->
            String filenameSuffix = variant.flavorName == "mono" ? variant.name : variant.buildType.name
            output.outputFileName = "android_${filenameSuffix}.apk"
        }
    }
}

// -------------------------------------------------------------------
// Tasks
// -------------------------------------------------------------------
task copyAndRenameBinary(type: Copy) {
    doNotTrackState("No need for up-to-date checks")

    String exportPath     = getExportPath()
    String exportFilename = getExportFilename()
    String exportEdition  = getExportEdition()
    String exportBuildType = getExportBuildType()
    String exportFormat   = getExportFormat()

    boolean isAab  = exportFormat == "aab"
    boolean isMono = exportEdition == "mono"
    String filenameSuffix = isMono ? (isAab ? "${exportEdition}-${exportBuildType}" : "${exportEdition}${exportBuildType.capitalize()}") 
                                   : (isAab ? "${exportEdition}-${exportBuildType}" : exportBuildType)

    String sourceFilename = isAab ? "build-${filenameSuffix}.aab" : "android_${filenameSuffix}.apk"
    String sourceFilepath = isAab ? "$buildDir/outputs/bundle/${exportEdition}${exportBuildType.capitalize()}/$sourceFilename"
                                  : "$buildDir/outputs/apk/$exportEdition/$exportBuildType/$sourceFilename"

    from sourceFilepath
    into exportPath
    rename sourceFilename, exportFilename
}

task validateJavaVersion {
    if (JavaVersion.current() != versions.javaVersion) {
        throw new GradleException("Invalid Java version ${JavaVersion.current()}. Required: ${versions.javaVersion}")
    }
}

// Ensure app preBuild runs after AAR copy
["copyDebugAARToAppModule", "copyDevAARToAppModule", "copyReleaseAARToAppModule"].each { taskName ->
    if (rootProject.tasks.findByPath(taskName) != null) {
        preBuild.mustRunAfter(rootProject.tasks.named(taskName))
    }
}